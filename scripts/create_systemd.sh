#!/usr/bin/env bash
set -euo pipefail

# ===== User-configurable paths =====
USER_NAME="${USER}"                                # e.g. rpi
HOME_DIR="${HOME}"
REPO_DIR="${HOME_DIR}/gits/LeanFrame"              # your repo
VENV_BIN="${REPO_DIR}/.venv/bin"                   # existing venv bin
PHOTO_DIR="${HOME_DIR}/DrivePhotos"                # local photo cache (for sync)
RCLONE_REMOTE="gdrive"                             # rclone remote name
DRIVE_PATH=""                                      # Drive folder name OR ID (keep quotes for ID)

# Pairing backend config
BACKEND_DIR="${REPO_DIR}/pairing_backend"
BACKEND_ENV_FILE="${BACKEND_DIR}/.env"            # will be parsed for REMOTE_* values
SECRETS_FILE="/etc/leanframe.secrets"             # root-only file to hold sensitive vars

SDL_DRIVER="x11"                 # default
WAYLAND_DISPLAY_NAME="wayland-0" # conventional name
DISPLAY_FALLBACK=":0"           # conventional X11 display

# Prefer Wayland if the socket exists in the current session
if [[ -n "${XDG_RUNTIME_DIR:-}" && -S "${XDG_RUNTIME_DIR}/${WAYLAND_DISPLAY_NAME}" ]]; then
  SDL_DRIVER="wayland"
fi

# Helper to emit Environment= lines for unit templates
emit_display_env_user() {
  if [[ "${SDL_DRIVER}" == "wayland" ]]; then
    # User unit uses its own %t runtime dir
    cat <<'EOT'
Environment=SDL_VIDEODRIVER=wayland
Environment=WAYLAND_DISPLAY=wayland-0

# Wait (best-effort) for the Wayland socket; no-op if it doesn't appear
ExecStartPre=/bin/sh -lc 'for i in $(seq 1 15); do [ -S "$XDG_RUNTIME_DIR/wayland-0" ] && exit 0; sleep 1; done; exit 0'
EOT
  else
    # X11 default
    cat <<EOT
Environment=SDL_VIDEODRIVER=x11
Environment=DISPLAY=${DISPLAY_FALLBACK}
# No Wayland wait needed; keep a no-op to avoid failures
ExecStartPre=/bin/true
EOT
  fi
}

emit_display_env_system() {
  # System unit must point at the user's runtime dir explicitly
  cat <<'EOT'
Environment=XDG_RUNTIME_DIR=/run/user/%U
EOT
  if [[ "${SDL_DRIVER}" == "wayland" ]]; then
    cat <<'EOT'
Environment=SDL_VIDEODRIVER=wayland
Environment=WAYLAND_DISPLAY=wayland-0
# Best-effort Wayland wait (no-op on non-Wayland)
ExecStartPre=/bin/sh -lc 'for i in $(seq 1 20); do [ -S "$XDG_RUNTIME_DIR/wayland-0" ] && exit 0; sleep 1; done; exit 0'
EOT
  else
    # X11 default
    cat <<EOT
Environment=SDL_VIDEODRIVER=x11
Environment=DISPLAY=${DISPLAY_FALLBACK}
# No Wayland wait needed
ExecStartPre=/bin/true
EOT
  fi
}

# ===== Sanity checks =====
[[ -d "${REPO_DIR}" ]] || { echo "ERROR: Repo not found at ${REPO_DIR}"; exit 1; }
[[ -x "${VENV_BIN}/python" ]] || {
  echo "ERROR: venv missing at ${VENV_BIN}. Create it then install requirements."
  echo "       python3 -m venv ${REPO_DIR}/.venv && source ${REPO_DIR}/.venv/bin/activate && pip install -r ${REPO_DIR}/requirements.txt"
  exit 1
}

RCLONE_CLIENT_ID=""
RCLONE_CLIENT_SECRET=""

if [[ -f "${BACKEND_ENV_FILE}" ]]; then
  # Robust .env parser for simple KEY=VALUE lines (handles quotes, ignores comments/blank lines)
  parse_env () {
    local key="$1"
    local line
    line="$(grep -E "^[[:space:]]*${key}[[:space:]]*=" "${BACKEND_ENV_FILE}" | tail -n1 || true)"
    [[ -n "${line}" ]] || { echo ""; return 0; }
    line="${line#*=}"
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%${line##*[![:space:]]}}"
    line="${line%\"}"; line="${line#\"}"
    line="${line%\'}"; line="${line#\'}"
    echo "$line"
  }

  RCLONE_CLIENT_ID="$(parse_env GOOGLE_CLIENT_ID)"
  RCLONE_CLIENT_SECRET="$(parse_env GOOGLE_CLIENT_SECRET)"
fi

# ===== Ensure photo dir and global env exist =====
mkdir -p "${PHOTO_DIR}"
sudo tee /etc/leanframe.env >/dev/null <<EOF
PHOTO_DIR=${PHOTO_DIR}
RCLONE_REMOTE=${RCLONE_REMOTE}
DRIVE_PATH="${DRIVE_PATH}"
RCLONE_CLIENT_ID="${RCLONE_CLIENT_ID}"
RCLONE_CLIENT_SECRET="${RCLONE_CLIENT_SECRET}"
EOF

# Write to a root-only secrets file so services can read them via EnvironmentFile=
sudo tee "${SECRETS_FILE}" >/dev/null <<EOF
# Generated by create_systemd.sh — do NOT commit this file.
RCLONE_CLIENT_ID=${RCLONE_CLIENT_ID}
RCLONE_CLIENT_SECRET=${RCLONE_CLIENT_SECRET}
EOF
sudo chmod 600 "${SECRETS_FILE}"

# ===== Create user units (~/.config/systemd/user) =====
USER_UNIT_DIR="${HOME_DIR}/.config/systemd/user"
mkdir -p "${USER_UNIT_DIR}"

# leanframe.service (Wayland user service with socket wait)
cat > "${USER_UNIT_DIR}/leanframe.service" <<EOF
[Unit]
Description=LeanFrame (user session; auto-detected display)
Wants=graphical-session.target
After=graphical-session.target

[Service]
Type=simple
WorkingDirectory=${REPO_DIR}
EnvironmentFile=/etc/leanframe.env
Environment=PYTHONUNBUFFERED=1
$(emit_display_env_user)
ExecStart=${VENV_BIN}/python -m photoframe
Restart=always
RestartSec=2

[Install]
WantedBy=default.target
EOF

# Path unit to start LeanFrame when Wayland socket appears
cat > "${USER_UNIT_DIR}/leanframe-wayland.path" <<EOF
[Unit]
Description=Start LeanFrame when Wayland socket appears

[Path]
PathExists=%t/wayland-0
Unit=leanframe.service

[Install]
WantedBy=default.target
EOF

## New: unified "setup" wrapper (system) that starts hotspot + setup_server + onboarding together
sudo tee /etc/systemd/system/leanframe-setup.service >/dev/null <<EOF
[Unit]
Description=LeanFrame first-run setup (AP + QR + setup server)
After=network-online.target
Wants=network-online.target
 
[Service]
Type=simple
User=${USER_NAME}
WorkingDirectory=${REPO_DIR}
Environment=PYTHONUNBUFFERED=1
Environment=AP_IP=192.168.4.1
$(emit_display_env_system)
ExecStartPre=/usr/bin/systemctl start leanframe-hotspot.service
ExecStart=${VENV_BIN}/python -m photoframe.setup_server
ExecStartPost=${VENV_BIN}/python -m photoframe.onboarding
ExecStopPost=/usr/bin/systemctl stop leanframe-hotspot.service
Restart=on-failure

[Install]
WantedBy=multi-user.target
EOF

# Boot switch: choose setup vs normal
sudo tee /etc/systemd/system/leanframe-switch.service >/dev/null <<'EOF'
[Unit]
Description=LeanFrame boot switch (setup vs normal)
After=network.target

[Service]
Type=oneshot
ExecStart=/bin/bash -lc '\
  STATE="/var/lib/leanframe/state.json"; \
  if [ -f "$STATE" ] && grep -q "\"provisioned\": true" "$STATE"; then \
    # Provisioned: stop setup, enable & start user wayland path (which starts leanframe.service). \
    systemctl stop leanframe-setup.service || true; \
    systemctl disable leanframe-setup.service || true; \
    loginctl enable-linger "${USER}"; \
    runuser -l "${USER}" -c "systemctl --user daemon-reload"; \
    runuser -l "${USER}" -c "systemctl --user enable leanframe-wayland.path"; \
    runuser -l "${USER}" -c "systemctl --user start  leanframe-wayland.path"; \
  else \
    # Not provisioned: disable user units and start setup. \
    runuser -l "${USER}" -c "systemctl --user stop  leanframe-wayland.path" || true; \
    runuser -l "${USER}" -c "systemctl --user disable leanframe-wayland.path" || true; \
    systemctl enable leanframe-setup.service; \
    systemctl start  leanframe-setup.service; \
  fi'
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
# Replace the USER placeholder inside the unit with the actual login user
sudo sed -i "s|\${USER}|${USER_NAME}|g" /etc/systemd/system/leanframe-switch.service

# leanframe-sync.service (system service for rclone sync)
# sudo tee /etc/systemd/system/leanframe-sync.service >/dev/null <<EOF
# [Unit]
# Description=LeanFrame: rclone sync Drive -> local photo cache
# Wants=network-online.target
# After=network-online.target

# [Service]
# User=${USER_NAME}
# EnvironmentFile=/etc/leanframe.env
# EnvironmentFile=${SECRETS_FILE}
# ExecStartPre=/usr/bin/mkdir -p "\${PHOTO_DIR}"
# ExecStart=/usr/bin/rclone sync "\${RCLONE_REMOTE}:\${DRIVE_PATH}" "\${PHOTO_DIR}" \\
#   --fast-list --transfers 4 --checkers 8 --create-empty-src-dirs=false

# EOF

# # Timer
# sudo tee /etc/systemd/system/leanframe-sync.timer >/dev/null <<EOF
# [Unit]
# Description=Run LeanFrame sync periodically (10 mins)

# [Timer]
# OnBootSec=2min
# OnUnitActiveSec=10min
# Unit=leanframe-sync.service

# [Install]
# WantedBy=timers.target
# EOF

# ===== Allow $USER_NAME to restart the switcher without password (sudoers drop-in) =====
# This enables the FastAPI /provision endpoint to run:
#   sudo systemctl restart leanframe-switch.service
# so the device flips from setup mode to runtime immediately (no reboot).
SUDOERS_DROPIN="/etc/sudoers.d/leanframe-switch"
sudo tee "${SUDOERS_DROPIN}" >/dev/null <<EOF
# LeanFrame: allow ${USER_NAME} to flip services after QR provisioning
# Only these exact commands are allowed, nothing else:
${USER_NAME} ALL=(ALL) NOPASSWD: /bin/systemctl restart leanframe-switch.service, /usr/bin/systemctl restart leanframe-switch.service
EOF
sudo chmod 440 "${SUDOERS_DROPIN}"
# Validate syntax; if invalid, visudo returns non-zero and the script (set -e) will exit.
sudo visudo -cf "${SUDOERS_DROPIN}"
echo "Created sudoers drop-in at ${SUDOERS_DROPIN} (validated)."

# --- Ensure NetworkManager is present (skip if you already use it) ---
if ! command -v nmcli >/dev/null 2>&1; then
  echo "ERROR: nmcli not found. Install NetworkManager and ensure wlan0 is managed by it."
fi

# --- Shared AP env (stable SSID/PSK derived from machine-id) ---
sudo mkdir -p /var/lib/leanframe
ID="$(cut -c1-8 /etc/machine-id)"
SSID="LeanFrame-${ID}"
PSK="Frame-${ID}"
sudo tee /var/lib/leanframe/setup_ap.env >/dev/null <<EOF
AP_SSID=${SSID}
AP_PSK=${PSK}
EOF
sudo chmod 644 /var/lib/leanframe/setup_ap.env

# --- Avahi (mDNS) advertisement for LeanFrame on _leanframe._tcp:8765 ---
# Install Avahi if missing
if ! dpkg -s avahi-daemon >/dev/null 2>&1; then
  echo "Installing avahi-daemon…"
  sudo apt-get update -y && sudo apt-get install -y avahi-daemon avahi-utils
fi

# Make sure Avahi is enabled
sudo systemctl enable --now avahi-daemon

# Device identity for TXT record (stable, non-secret)
DEVICE_ID="LF-${ID}"     # e.g., LF-1A2B3C4D from /etc/machine-id first 8 chars

# Create the service file
sudo mkdir -p /etc/avahi/services
sudo tee /etc/avahi/services/leanframe.service >/dev/null <<EOF
<?xml version="1.0" standalone='no'?>
<!DOCTYPE service-group SYSTEM "avahi-service.dtd">
<service-group>
  <name replace-wildcards="yes">LeanFrame %h</name>
  <service>
    <type>_leanframe._tcp</type>
    <port>8765</port>
    <!-- Keep TXT minimal; do NOT put secrets here -->
    <txt-record>device_id=${DEVICE_ID}</txt-record>
    <txt-record>api=/</txt-record>
    <txt-record>version=1</txt-record>
  </service>
</service-group>
EOF

# Reload Avahi so the announcement goes live
sudo systemctl reload avahi-daemon || sudo systemctl restart avahi-daemon

# (Optional) If you use UFW, allow mDNS so phones can discover the frame
if command -v ufw >/dev/null 2>&1; then
  sudo ufw allow 5353/udp || true
fi

# --- Install hotspot helper ---
sudo tee /usr/local/bin/leanframe-ap >/dev/null <<'EOF'
#!/usr/bin/env bash
set -euo pipefail
ENV_FILE="/var/lib/leanframe/setup_ap.env"
IFACE="${IFACE:-wlan0}"
CON_NAME="leanframe-setup"
[[ -f "$ENV_FILE" ]] || { echo "Missing $ENV_FILE"; exit 1; }
source "$ENV_FILE"
SSID="${AP_SSID:?}"
PSK="${AP_PSK:?}"
case "${1:-}" in
  up)
    if nmcli -t -f NAME connection show | grep -qx "$CON_NAME"; then
      nmcli connection modify "$CON_NAME" 802-11-wireless.ssid "$SSID" \
      802-11-wireless.mode ap 802-11-wireless.band bg \
      ipv4.method shared ipv4.addresses 192.168.4.1/24 \
      wifi-sec.key-mgmt wpa-psk wifi-sec.psk "$PSK" connection.autoconnect no
    else
      nmcli connection add type wifi ifname "$IFACE" con-name "$CON_NAME" ssid "$SSID"
      nmcli connection modify "$CON_NAME" 802-11-wireless.mode ap 802-11-wireless.band bg \
      ipv4.method shared ipv4.addresses 192.168.4.1/24 \
      wifi-sec.key-mgmt wpa-psk wifi-sec.psk "$PSK" connection.autoconnect no
  fi
    nmcli connection up "$CON_NAME"
    ;;
  down)
    nmcli -t -f NAME connection show | grep -qx "$CON_NAME" && nmcli connection down "$CON_NAME" || true
    ;;
  delete)
    nmcli -t -f NAME connection show | grep -qx "$CON_NAME" && nmcli connection delete "$CON_NAME" || true
    ;;
  *) echo "Usage: $0 {up|down|delete}"; exit 2;;
esac
EOF
sudo chmod 0755 /usr/local/bin/leanframe-ap

# --- System service for hotspot ---
sudo tee /etc/systemd/system/leanframe-hotspot.service >/dev/null <<'EOF'
[Unit]
Description=LeanFrame onboarding hotspot (NetworkManager AP)
Wants=NetworkManager.service
After=NetworkManager.service

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/bin/leanframe-ap up
ExecStop=/usr/local/bin/leanframe-ap down

[Install]
WantedBy=multi-user.target
EOF

# ===== Make the user manager survive boot (do once) =====
sudo loginctl enable-linger "${USER_NAME}"

# ===== Disable and remove any old system service  =====
if systemctl list-unit-files | grep -q '^leanframe.service'; then
  sudo systemctl disable --now leanframe.service || true
  sudo rm -f /etc/systemd/system/leanframe.service || true
  sudo systemctl daemon-reload || true
fi

# ===== Ensure state dir exists and is writable by ${USER_NAME} =====
sudo install -d -m 0775 -o "${USER_NAME}" -g "${USER_NAME}" /var/lib/leanframe
# ===== Enable & start user/system units =====
systemctl --user daemon-reload
sudo systemctl daemon-reload
sudo systemctl enable --now leanframe-switch.service
sudo systemctl enable --now leanframe-sync.timer
sudo systemctl start  leanframe-sync.service || true

echo "-------------------------------------------------------------"
echo "User units (created):"
echo "  ${USER_UNIT_DIR}/leanframe.service"
echo "  ${USER_UNIT_DIR}/leanframe-wayland.path"
echo "System units:"
echo "  /etc/systemd/system/leanframe-switch.service"
echo "  /etc/systemd/system/leanframe-sync.service"
echo "  /etc/systemd/system/leanframe-sync.timer"
echo
echo "Boot switch status:"
echo "  sudo systemctl status leanframe-switch.service"
echo
echo "First boot (not provisioned): setup service runs."
echo "After provisioning (provisioned=true):"
echo "  switcher stops setup and enables user leanframe-wayland.path -> leanframe.service"
echo "-------------------------------------------------------------"
